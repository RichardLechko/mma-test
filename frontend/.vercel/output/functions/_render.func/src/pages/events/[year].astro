---
import Layout from '../../layouts/Layout.astro';
import FilterDropdown from '../../components/FilterDropdown.astro';
import { supabase } from '../../lib/supabase';

// Get the year from the URL parameter
const { year: yearParam } = Astro.params;
const yearNum = parseInt(yearParam || new Date().getFullYear().toString());

// Validate year or default to current
const currentYear = new Date().getFullYear();
const validYear = !isNaN(yearNum) ? yearNum : currentYear;
const isHistoricalYear = validYear < currentYear;

// Get all available years for dropdown
let availableYears: string[] = [validYear.toString()];
try {
  const { data, error } = await supabase
    .from('events')
    .select('event_date');
  
  if (!error && data) {
    // Extract years, filter out invalid dates, and remove duplicates
    const years = data
      .map(event => {
        const date = new Date(event.event_date);
        return !isNaN(date.getTime()) ? date.getFullYear() : null;
      })
      .filter(year => year !== null);
    
    // Make sure current year is included
    if (!years.includes(currentYear)) {
      years.push(currentYear);
    }
    
    // Get unique years and sort in descending order
    availableYears = [...new Set(years)]
      .sort((a, b) => b - a)
      .map(y => y.toString());
  }
} catch (error) {
  console.error('Error fetching years:', error);
}

// Create year options for dropdown
const yearOptions = availableYears.map(year => ({
  value: year,
  label: year
}));
---

<Layout title={`UFC Events - ${validYear}`}>
  <main class="events-page">
    <section class="events-container">
      <div class="events-header">
        <h1>UFC Events {validYear}</h1>
        
        <!-- Year filter dropdown using your FilterDropdown component -->
        <FilterDropdown
          label="Year"
          options={yearOptions}
          currentValue={validYear.toString()}
          id="year-selector"
        />
        
        <!-- Hidden select for the redirect functionality -->
        <select id="year-selector" class="hidden-select">
          {availableYears.map(year => (
            <option value={year} selected={year === validYear.toString()}>
              {year}
            </option>
          ))}
        </select>
      </div>
      
      <div id="events-container" data-year={validYear} data-is-current-year={isHistoricalYear ? 'false' : 'true'}>
        <div class="loading-container">
          <div class="loading-spinner"></div>
          <p>Loading events for {validYear}...</p>
        </div>
      </div>
    </section>
  </main>
</Layout>

<script>
  import { supabase } from '../../lib/supabase';
  
  // Cache keys
  const EVENTS_CACHE_PREFIX = 'mmascheduler-events-';
  
  // Constants
  const INITIAL_LOAD = 10;
  
  // Type definitions
  interface Event {
    id: string;
    name: string;
    event_date: string;
    venue: string | null;
    city: string | null;
    country: string | null;
  }
  
  // Main initialization
  document.addEventListener('DOMContentLoaded', async () => {
    // Get container and year
    const container = document.getElementById('events-container');
    if (!container) return;
    
    const year = parseInt(container.dataset.year || '0');
    const isCurrentYear = container.dataset.isCurrentYear === 'true';
    
    // Set up year selector to redirect
    const yearSelector = document.getElementById('year-selector');
    if (yearSelector) {
      yearSelector.addEventListener('change', (e) => {
        const target = e.target as HTMLSelectElement;
        window.location.href = `/events/${target.value}`;
      });
    }
    
    // Load events
    await loadEvents(year, isCurrentYear);
  });
  
  // Load events for the selected year
  async function loadEvents(year: number, isCurrentYear: boolean) {
    const container = document.getElementById('events-container');
    if (!container) return;
    
    try {
      // Create date range for the year
      const startDate = new Date(year, 0, 1).toISOString();
      const endDate = new Date(year, 11, 31, 23, 59, 59).toISOString();
      
      // Check cache for historical years
      const cacheKey = `${EVENTS_CACHE_PREFIX}${year}`;
      let events: Event[] = [];
      let totalCount = 0;
      
      // For historical years, try cache first
      if (!isCurrentYear) {
        const cachedEvents = localStorage.getItem(cacheKey);
        if (cachedEvents) {
          const cachedData = JSON.parse(cachedEvents);
          events = cachedData.events;
          totalCount = cachedData.total;
          
          // If we have cached events, render them
          if (events && events.length > 0) {
            renderEvents(events, year, isCurrentYear, totalCount);
            return;
          }
        }
      }
      
      // Initial events load (limited for historical years)
      const limit = isCurrentYear ? 50 : INITIAL_LOAD;
      
      // Get events
      const { data, error } = await supabase
        .from('events')
        .select('id, name, event_date, venue, city, country')
        .gte('event_date', startDate)
        .lte('event_date', endDate)
        .order('event_date', { ascending: true })
        .limit(limit);
      
      if (error) throw error;
      
      events = data || [];
      
      // Get total count for historical years
      if (!isCurrentYear) {
        const { count, error: countError } = await supabase
          .from('events')
          .select('id', { count: 'exact', head: true })
          .gte('event_date', startDate)
          .lte('event_date', endDate);
        
        if (!countError && count !== null) {
          totalCount = count;
          
          // Cache the results for historical years
          localStorage.setItem(cacheKey, JSON.stringify({
            events: events,
            total: totalCount,
            timestamp: Date.now()
          }));
        }
      }
      
      // Render the events
      renderEvents(events, year, isCurrentYear, totalCount);
    } catch (error) {
      console.error('Error loading events:', error);
      if (container) {
        container.innerHTML = `
          <div class="no-events">
            <p>Error loading events. Please try again later.</p>
          </div>
        `;
      }
    }
  }
  
  // Render events to the container
  function renderEvents(events: Event[], year: number, isCurrentYear: boolean, totalCount: number) {
    const container = document.getElementById('events-container');
    if (!container) return;
    
    // If no events, show empty message
    if (!events || events.length === 0) {
      container.innerHTML = `
        <div class="no-events">
          <p>No events found for ${year}.</p>
        </div>
      `;
      return;
    }
    
    // Sort current year events by proximity to today
    const today = new Date();
    if (isCurrentYear) {
      events.sort((a: Event, b: Event) => {
        const dateA = new Date(a.event_date);
        const dateB = new Date(b.event_date);
        
        if ((dateA >= today && dateB >= today) || (dateA < today && dateB < today)) {
          return dateA >= today 
            ? dateA.getTime() - dateB.getTime() 
            : dateB.getTime() - dateA.getTime();
        }
        
        return dateA >= today ? -1 : 1;
      });
    }
    
    // Create HTML for events
    let html = `<div class="events-grid">`;
    
    events.forEach((event: Event) => {
      const eventDate = new Date(event.event_date);
      const statusClass = eventDate > today ? 'status-scheduled' : 'status-completed';
      
      html += `
        <a href="/events/event/${event.id}" class="event-card ${statusClass}" data-event-date="${event.event_date}">
          <div class="event-header ${statusClass}">
            <h2>${event.name}</h2>
            <span class="event-countdown"></span>
          </div>
          <div class="event-details">
            <p class="event-date"></p>
            <p class="event-location">
              ${event.venue 
                ? `<span class="venue">${event.venue}</span>
                   ${event.city && event.country 
                     ? `<span class="location">${event.city}, ${event.country}</span>` 
                     : ''}`
                : `<span class="location-tbd">Location TBD</span>`}
            </p>
            <p class="event-status">${eventDate > today ? 'Upcoming' : 'Completed'}</p>
          </div>
        </a>
      `;
    });
    
    html += `</div>`;
    
    // Add load more button for historical years if needed
    if (!isCurrentYear && events.length < totalCount) {
      const loadedCount = events.length;
      html += `
        <div class="load-more-container">
          <button id="load-more-btn" class="load-more-btn" data-year="${year}" data-offset="${loadedCount}" data-total="${totalCount}">
            Load More Events (${loadedCount}/${totalCount})
          </button>
        </div>
      `;
    }
    
    // Update the container
    container.innerHTML = html;
    
    // Initialize event dates
    updateEventDates();
    
    // Set up load more button
    const loadMoreBtn = document.getElementById('load-more-btn');
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener('click', loadMoreEvents);
    }
  }
  
  // Update event dates
  function updateEventDates() {
    // Get all event cards
    const eventCards = document.querySelectorAll('.event-card');
    
    // Get today's date with time set to midnight for proper day comparison
    const today = new Date();
    const todayAtMidnight = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    
    eventCards.forEach(card => {
      // Get the UTC date string
      const utcDateStr = card.getAttribute('data-event-date');
      if (!utcDateStr) return;
      
      // Create a date object which automatically converts to local time
      const localDate = new Date(utcDateStr);
      
      // Format date in user's locale
      const formattedDate = localDate.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      
      // Add time in local timezone
      const formattedTime = localDate.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        timeZoneName: 'short'
      });
      
      // Update date display with local time
      const dateElement = card.querySelector('.event-date');
      if (dateElement) {
        dateElement.textContent = `${formattedDate} at ${formattedTime}`;
      }
      
      // Calculate if the event is in the past
      const isPastEvent = localDate < todayAtMidnight;
      
      // Calculate days difference
      const diffDays = calculateDaysDifference(localDate, todayAtMidnight);
      
      // Handle "tomorrow", "today" and other cases
      let timeDisplay;
      if (!isPastEvent) {
        // Future event
        if (diffDays === 0) {
          timeDisplay = "Today";
        } else if (diffDays === 1) {
          timeDisplay = "Tomorrow";
        } else {
          timeDisplay = `${diffDays} days away`;
        }
      } else {
        // Past event
        if (diffDays === 0) {
          timeDisplay = "Today";
        } else if (diffDays === 1) {
          timeDisplay = "Yesterday";
        } else {
          timeDisplay = `${diffDays} days ago`;
        }
      }
      
      // Update the countdown display
      const countdownElement = card.querySelector('.event-countdown');
      if (countdownElement) {
        countdownElement.textContent = timeDisplay;
      }
    });
  }
  
  // Calculate days difference between two dates
  function calculateDaysDifference(date1: Date, date2: Date): number {
    // Set both dates to midnight to get accurate day count
    const d1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
    const d2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    
    // Get the time difference in milliseconds
    const timeDiff = Math.abs(d2.getTime() - d1.getTime());
    
    // Convert to days and round to handle DST changes
    return Math.round(timeDiff / (1000 * 60 * 60 * 24));
  }
  
  // Load more events
  async function loadMoreEvents() {
    const loadMoreBtn = document.getElementById('load-more-btn') as HTMLButtonElement;
    if (!loadMoreBtn) return;
    
    // Get data attributes
    const year = parseInt(loadMoreBtn.dataset.year || '0');
    const offset = parseInt(loadMoreBtn.dataset.offset || '0');
    const total = parseInt(loadMoreBtn.dataset.total || '0');
    const limit = 10; // Load 10 more events each time
    
    // Disable button and show loading indicator
    loadMoreBtn.disabled = true;
    loadMoreBtn.innerHTML = 'Loading... <span class="loading"></span>';
    
    try {
      // Create date range for the year
      const startDate = new Date(year, 0, 1).toISOString();
      const endDate = new Date(year, 11, 31, 23, 59, 59).toISOString();
      
      // Get more events
      const { data, error } = await supabase
        .from('events')
        .select('id, name, event_date, venue, city, country')
        .gte('event_date', startDate)
        .lte('event_date', endDate)
        .order('event_date', { ascending: true })
        .range(offset, offset + limit - 1);
        
      if (error) throw error;
      
      const moreEvents = data || [];
      
      if (moreEvents.length > 0) {
        const eventsGrid = document.querySelector('.events-grid');
        
        if (eventsGrid) {
          // Add new event cards
          moreEvents.forEach((event: Event) => {
            const today = new Date();
            const eventDate = new Date(event.event_date);
            const statusClass = eventDate > today ? 'status-scheduled' : 'status-completed';
            
            const eventCard = document.createElement('a');
            eventCard.href = `/events/event/${event.id}`;
            eventCard.className = `event-card ${statusClass}`;
            eventCard.dataset.eventDate = event.event_date;
            
            eventCard.innerHTML = `
              <div class="event-header ${statusClass}">
                <h2>${event.name}</h2>
                <span class="event-countdown"></span>
              </div>
              <div class="event-details">
                <p class="event-date"></p>
                <p class="event-location">
                  ${event.venue 
                    ? `<span class="venue">${event.venue}</span>
                       ${event.city && event.country 
                         ? `<span class="location">${event.city}, ${event.country}</span>` 
                         : ''}`
                    : `<span class="location-tbd">Location TBD</span>`}
                </p>
                <p class="event-status">${eventDate > today ? 'Upcoming' : 'Completed'}</p>
              </div>
            `;
            
            eventsGrid.appendChild(eventCard);
          });
          
          // Update the cache
          const cacheKey = `${EVENTS_CACHE_PREFIX}${year}`;
          const cachedEvents = localStorage.getItem(cacheKey);
          
          if (cachedEvents) {
            const cachedData = JSON.parse(cachedEvents);
            cachedData.events = [...cachedData.events, ...moreEvents];
            localStorage.setItem(cacheKey, JSON.stringify(cachedData));
          }
          
          // Update dates for new cards
          updateEventDates();
          
          // Update loaded count
          const newOffset = offset + moreEvents.length;
          const loadedCount = Math.min(newOffset, total);
          
          // Update button text and data
          loadMoreBtn.dataset.offset = newOffset.toString();
          loadMoreBtn.innerHTML = `Load 10 More Events (${loadedCount}/${total})`;
          
          // Hide button if all events are loaded
          if (loadedCount >= total) {
            loadMoreBtn.style.display = 'none';
          }
        }
      } else {
        // No more events
        loadMoreBtn.style.display = 'none';
      }
    } catch (error) {
      console.error('Error loading more events:', error);
      loadMoreBtn.innerHTML = 'Error loading events. Try again.';
    } finally {
      // Re-enable button
      loadMoreBtn.disabled = false;
    }
  }
</script>

<style>
  .hidden-select {
    display: none;
  }
</style>
